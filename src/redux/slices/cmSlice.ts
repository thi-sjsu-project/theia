import { createSlice } from '@reduxjs/toolkit';
import type { PayloadAction } from '@reduxjs/toolkit';
import type { Widget } from '../../types/modalities';
import type { Message } from 'src/types/schema-types';
import type { Cell, Section } from 'src/types/support-types';

const defaultCell: Cell = {
  widgetIDs: [],
  priority: 0,
  type: 'free',
};

type InitialState = {
  visualComplexity: number;
  audioComplexity: number;
  widgets: Widget[];
  messages: Message[];
  pixelMap: Cell[][];
  sections: Section[];
  /* ADD MORE AS NEEDED... */
};

const initialState: InitialState = {
  visualComplexity: 0,
  audioComplexity: 0,
  widgets: [],
  messages: [],
  pixelMap: new Array(1080).fill(new Array(1920).fill(defaultCell)),
  sections: [],
};

export const cmSlice = createSlice({
  name: 'cm',
  initialState,
  // reducers are used to update the state
  reducers: {
    /* initializeMap: (state) => {
      //given a location on the grid (top-left to bottom-right), make those pixels the given section
      const defaultCell: Cell = {
        widgetIDs: [],
        priority: 0,
        type: 'free',
      };
      state.pixelMap = new Array(1080)
        .fill(new Array(1920).fill(defaultCell))
        console.log(state.pixelMap);
    }, */
    addMapSection: (state, action) => {
      const section = action.payload;

      const tempCell: Cell = {
        widgetIDs: [],
        priority: section.priority,
        type: section.type,
      };

      for (let col = section.x; col < section.x + section.w; col++) {
        //add  the specified cell to the pixel map to create section region
        for (let row = section.y; row < section.y + section.h; row++) {
          state.pixelMap[row][col] = tempCell;
        }
      }
      state.sections.push(section); //add it to our sections as well
    },
    addWidget: (state, action: PayloadAction<Widget>) => {
      state.widgets.push(action.payload); //add to the widgets
      for (
        let x = action.payload.x;
        x < action.payload.x + action.payload.w;
        x++
      ) {
        //add the widgetID to the cells it is filling
        for (
          let y = action.payload.y;
          y < action.payload.y + action.payload.h;
          y++
        ) {
          state.pixelMap[x][y].widgetIDs.push(action.payload.id);
        }
      }
    },
    removeWidget: (state, action: PayloadAction<string>) => {
      state.widgets = state.widgets.filter(
        (widget) => widget.id !== action.payload,
      );
    },

    // delete an element from a widget by id
    updateWidgetDelete: (state, action: PayloadAction<string>) => {
      state.widgets = state.widgets.map((widget) => {
        return {
          ...widget,
          elements: widget.elements.filter(
            (element) => element.id !== action.payload,
          ),
        };
      });
    },

    toggleElementInteraction: (state, action: PayloadAction<string>) => {
      state.widgets = state.widgets.map((widget) => {
        if (widget.id === action.payload) {
          return {
            ...widget,
            elements: widget.elements.map((element) => {
              return {
                ...element,
                interacted: !element.interacted,
              };
            }),
          };
        }
        return widget;
      });
    },

    updateVisualComplexity: (state, action: PayloadAction<number>) => {
      state.visualComplexity = action.payload;
    },
    updateAudioComplexity: (state, action: PayloadAction<number>) => {
      state.audioComplexity = action.payload;
    },

    addMessage: (state, action: PayloadAction<Message>) => {
      state.messages.push(action.payload);
    },
  },
  // selectors are used to access parts of the state within components
  selectors: {
    getSections: (state) => state.sections,
    getPixelMap: (state) => state.pixelMap,
    getWidgets: (state) => state.widgets,
    // find a single widget by id
    getWidgetById: (state, id: string) =>
      state.widgets.find((widget) => widget.id === id),
    getVisualComplexity: (state) => state.visualComplexity,
    getAudioComplexity: (state) => state.audioComplexity,
    getMessages: (state) => state.messages,
  },
});

// action creators (automatically generated by createSlice for each reducer)
export const {
  addMapSection,
  addMessage,
  addWidget,
  removeWidget,
  updateWidgetDelete,
  updateVisualComplexity,
  updateAudioComplexity,
  toggleElementInteraction,
} = cmSlice.actions;

export const {
  getSections,
  getPixelMap,
  getWidgets,
  getWidgetById,
  getMessages,
  getVisualComplexity,
  getAudioComplexity,
} = cmSlice.selectors;
